# Skip #!/bin/sh - Dash has issues with read options.  Bash, Ash are OK.

# keys
E=$(printf "\033")
NL='
'

# ANSI colors
N="${E}[0m"
WB="${E}[1;44;37m"
BW="${E}[0;47;34m"

# Two charsets.
G0=$(printf "\017")
G1=$(printf "\016")

# openwrt zipit only seems to have graphic chars on charset G1
DRAW="${G1}${E})0"
TEXT="${G0}${E}(B"

# $I and $J are global widget indices.

px() # printat y x
{
  printf "${E}[%d;%dH" ${1:-1} ${2:-1}
  [ $# -gt 2 ] && {
    shift 2
    printf "%s" "$*"
  }
}

get_key() # Skips Space and NL, but works in ash without stty.
{
  read -rsn1 _KEY
  case "${_KEY}" in
     "${E}") _K=""; read -n1 -t1 _K; _KEY="${E}${_K}"; 
	[ -n "_K" ] && { _K=""; read -n1 -t1 _K; _KEY="${_KEY}${_K}"; }
  ;; "") _KEY=" "
  ;;
  esac
}

##### Get TUI screen offset  ######
_K=""
echo -en "${E}[s${E}[999;999H${E}[6n${E}[u"
read -sn6 -t1 S
read -sn1 -t1 _K; S="${S}${_K}"; 
[ -n "_K" ] && { _K=""; read -sn1 -t1 _K; S="${S}${_K}"; }

S="${S#*[}"
COL="${S#*;}"
COL="${COL%*R}"
ROW="${S%;*}"
Y=$((($ROW - 19) / 2 + 1))
X=$((($COL - 45) / 2 + 1))

# Define TUI Widgets (Name, FieldLen, Location, EraseStr)
# (no widget types needed for menu)
x=$(($X + 1))
######   Message strings  ######
S41="$(printf "%-41s")"
WS1="S1"; WL1=41; WA1="${E}[$(($Y + 2));${x}H";  WE1="$WA1$S41$WA1"
WS2="S2"; WL2=41; WA2="${E}[$(($Y + 3));${x}H";  WE2="$WA2$S41$WA2"
WS3="S3"; WL3=41; WA3="${E}[$(($Y + 4));${x}H";  WE3="$WA3$S41$WA3"
######   Menu Options  ######
x=$(($X + 2))
WS4="OP4"; WL4=41; WA4="${E}[$(($Y + 6));${x}H"; WE4="$WA4$S41$WA4"
WS5="OP5"; WL5=41; WA5="${E}[$(($Y + 7));${x}H"; WE5="$WA5$S41$WA5"
WS6="OP6"; WL6=41; WA6="${E}[$(($Y + 8));${x}H"; WE6="$WA6$S41$WA6"
WS7="OP7"; WL7=41; WA7="${E}[$(($Y + 9));${x}H"; WE7="$WA7$S41$WA7"
WS8="OP8"; WL8=41; WA8="${E}[$(($Y + 10));${x}H"; WE8="$WA8$S41$WA8"
WS9="OP9"; WL9=41; WA9="${E}[$(($Y + 11));${x}H"; WE9="$WA9$S41$WA9"
WS10="OP10"; WL10=41; WA10="${E}[$(($Y + 12));${x}H"; WE10="$WA10$S41$WA10"
WS11="OP11"; WL11=41; WA11="${E}[$(($Y + 13));${x}H"; WE11="$WA11$S41$WA11"
WS12="OP12"; WL12=41; WA12="${E}[$(($Y + 14));${x}H"; WE12="$WA12$S41$WA12"
#######  Buttons  #######
# Button text lengths must fit in the boxes laid out in DRAW mode.
y=$(($Y + 17)) 
WS20="B1"; WL20=5; WA20="${E}[${y};$(($X + 5))H";  WE20="$WA20     $WA20"
WS21="B2"; WL21=4; WA21="${E}[${y};$(($X + 20))H"; WE21="$WA21    $WA21"
WS22="B3"; WL22=6; WA22="${E}[${y};$(($X + 34))H"; WE22="$WA22      $WA22"

B1="Sleep"; B2="Stop"; B3="Cancel"
###################
ShowTUI()
{
printf "${E}[2J"

# Must use UPPERCASE for any words in DRAW mode.  Or add labels later.
px $(($Y + 0))  $X "$WB$DRAW"
px $(($Y + 1))  $X "lqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqk"
px $(($Y + 2))  $X "x                                           x"
px $(($Y + 3))  $X "x                                           x"
px $(($Y + 4))  $X "x                                           x"
px $(($Y + 5))  $X "tqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqu"
px $(($Y + 6))  $X "x                                           x"
px $(($Y + 7))  $X "x                                           x"
px $(($Y + 8))  $X "x                                           x"
px $(($Y + 9))  $X "x                                           x"
px $(($Y + 10)) $X "x                                           x"
px $(($Y + 11)) $X "x                                           x"
px $(($Y + 12)) $X "x                                           x"
px $(($Y + 13)) $X "x                                           x"
px $(($Y + 14)) $X "x                                           x"
px $(($Y + 15)) $X "tqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqu"
px $(($Y + 16)) $X "x  lqqqqqqqk      lqqqqqqqk     lqqqqqqqqk  x"
px $(($Y + 17)) $X "x  x       x      x       x     x        x  x"
px $(($Y + 18)) $X "x  mqqqqqqqj      mqqqqqqqj     mqqqqqqqqj  x"
px $(($Y + 19)) $X "mqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqj"
printf "$TEXT$WB"
# 
# Done with DRAW mode.  Now we can use lower case.
#
echo "${WE1}            Radio Sleep/Shutoff Timer"
echo "${WE3}How long before the music stops?"

# Menu options.  Draw the selected text BW reverse text.
OP4="5 Minutes";
OP5="10 Minutes";
OP6="20 Minutes";
OP7="30 minutes";
OP8="45 minutes";
OP9="1 Hour";
OP10="2 Hours";
OP11="3 Hours";
OP12="User defined";

echo "${WE4}${BW}${OP4}${WB}"
echo "${WE5}${OP5}"
echo "${WE6}${OP6}"
echo "${WE7}${OP7}"
echo "${WE8}${OP8}"
echo "${WE9}${OP9}"
echo "${WE10}${OP10}"
echo "${WE11}${OP11}"
echo "${WE12}${OP12}"

# Draw selected button text BW reverse text.
echo "${WE20}${BW}${B1}${WB}${WE21}${B2}${WE22}${B3}"
}

# Boolean/PushButton handler
button()
{
  eval SP=\$WS$J
  eval STR=\$"$SP"
  case $I in 
    20) echo "STR=\"$STR\"; break" ; return ;;
    21) echo "break" ; return ;; 
    22) echo "break" ; return ;; 
  esac
}

#######
ShowTUI

# Initial setup.  Start at 1st menu op and button.
J=4
I=20; y=17; x=5
eval SP=\$WS$I
eval STR=\$"$SP"

# Run main dialog box until ESC
while :
do
px $(($Y + $y)) $(($X + $x))
get_key
MV=0 # Handle widget traversal (UP,DN,TAB).
case $_KEY in
   " ") eval $(button)
;; ${NL}) eval $(button)
;; "${E}") STR="Cancel"; break
;; "${E}[A") MV=$J ; J=$(($J - 1)) #UP
;; "${E}[B") MV=$J ; J=$(($J + 1)) #DN
;; "${E}[C") MV=$I ; I=$(($I + 1)) #>>
;; "${E}[D") MV=$I ; I=$(($I - 1)) #<<
;;
esac

# Set x and y if traversing between widgets
if [ $MV -ne 0 ] ; then
  # Clear and restore old menu option before moving on.
  eval WE=\$WE$MV
  eval SP=\$WS$MV
  eval STR=\$"$SP"
  echo "${WB}${WE}${STR}${BW}"
  if [ $MV -lt 20 ] ; then # Switch Menu Option
    [ "$J" -lt 4 ] && J=4
    [ "$J" -gt 12 ] && J=12
    y=$(($J + 2));  x=2
    eval SP=\$WS$J
    eval STR=\$"$SP"
    px $(($Y + $y)) $(($X + $x)) $STR
  fi
  # Always redraw button last
  [ "$I" -lt 20 ] && I=20
  [ "$I" -gt 22 ] && I=22
  if [ "$I" -eq 20 ] ; then y=17; x=5
  elif [ "$I" -eq 21 ] ; then y=17; x=20
  elif [ "$I" -eq 22 ] ; then y=17; x=34
  fi
  eval SP=\$WS$I
  eval STR=\$"$SP"
  px $(($Y + $y)) $(($X + $x)) $STR
fi
done

# Go to top left (1,1), set normal text, fix tty
px 1 1 $N
stty sane
clear

# Act on selection.
var=$(IFS=" " ; set -- $STR ; echo $1)

pidfile="/tmp/apps/sleeptimer"

if [ "$var" = "Stop" ]; then
  if [ -e "$pidfile" ]; then
    kill `cat "$pidfile"`
    rm "$pidfile"
    echo "Sleep timer stopped"
  else
    echo "Sleep timer not running"
  fi
  sleep 3
  exit 0
elif [ "$var" = "User" ] 2>/dev/null; then
  echo "How many minutes before the music stops?"
  read var
elif [ "$var" -lt 5 ] 2>/dev/null; then
  var=$(( var * 60  )) # Convert hours to minutes
fi
if [ "$var" -eq "$var" ] 2>/dev/null; then
  deallocvt
  # Sleep, then run onStop
  openvt -- sleeptimer $var
  echo "Timer set for $var minutes"
else
  # Not a number or user cancelled
  echo "Invalid time or cancelled"
fi

sleep 3

